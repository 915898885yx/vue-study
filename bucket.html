<!DOCTYPE html>
<html lang="zh-cn">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title></title>
</head>
<body>
<div id="app"></div>
</body>
<script type="text/javascript">
	// const data = {
  //   text: 'hello world',
  //   ok: true
  // }

  const data = {
    foo: 1,
    bar: 2,
    objInfo: {
      obj1: 1
    }
  }

  const bucket = new WeakMap()
  console.log(bucket, 'bucket')
  const ITERATE_KEY = Symbol()
  // 一个标记变量，代表是否进行跟踪
  let shouldTrack = true
  const arrayInstrumentations = {}
  ;['push', 'pop', 'shift', 'unshift', 'splice'].forEach(method => {
    const originMethod = Array.prototype[method]
    // 重写方法
    arrayInstrumentations[method] = function (...args) {
      // 调用原始方法前，禁止追踪
      shouldTrack = false
      const res = originMethod.apply(this, args)
      shouldTrack = true
      return res
    }
  })

  const proxyConfig = {
    get (target, key, receiver) {
      console.log('get:', target, key)
      // 代理对象可以通过raw属性访问原始数据
      if (key === 'raw') {
        return target
      }
      track(target, key)

      return Reflect.get(target, key, receiver)
    },
    set (target, key, newVal, receiver) {
      console.log('set:', target, key)
      // old
      const oldVal = target[key]
      // 如果属性不存在，则说明是添加新属性，否则是设置已有属性
      const type = Array.isArray(target)
        ? Number(key) < target.length ? 'SET' : 'ADD'
        : Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'
      // const type = Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'
      const res = Reflect.set(target, key, newVal, receiver)
      // target === receiver.raw 说明recevier就是target的代理对象 --- 解决访问到原型属性上，多次触发trigger
      if (target === receiver.raw) {
        // 当新值和旧值不相等并且都不是NaN时才触发trigger
        if (oldVal !== newVal && (oldVal === oldVal || newVal === newVal)) {
          trigger(target, key, type, newVal)
        }
      }
      return res
    },
    has (target, key) { // 拦截 'a' in obj操作
      track(target, key)
      return Reflect.has(target, key)
    },
    ownKeys (target) { // 拦截for...in循环
      track(target, Array.isArray(target) ? 'length' : ITERATE_KEY)
      return Reflect.ownKeys(target)
    },
    deleteProperty (target, key) {
      // 检查被操作属性是否是对象自己的属性
      const hadKey = Object.prototype.hasOwnProperty.call(target, key)
      // 使用Relect.deleteProperty删除属性
      const res = Reflect.deleteProperty(target, key)
      if (res && hadKey) {
        trigger(target, key, 'DELETE')
      }
      return res
    }
  }

  const obj = new Proxy(data, proxyConfig)

  function track (target, key) { 
    if (!activeEffect || !shouldTrack) return target[key]

    let depsMap = bucket.get(target)

    if (!depsMap) {
      bucket.set(target, ( depsMap = new Map() ))
    }

    let deps = depsMap.get(key)

    if (!deps) {
      depsMap.set(key, ( deps = new Set() ))
    }

    deps.add(activeEffect)
    // 将集合放到activeEffect.deps数组中
    activeEffect.deps.push(deps)
  }

  function trigger (target, key, type, newVal) {
    const depsMap = bucket.get(target)

    if (!depsMap) return
    // 取得与key相关的副作用函数
    const effects = depsMap.get(key)

    // 取得与ITERATE_KEY相关的副作用函数
    const iterateEffects = depsMap.get(ITERATE_KEY)
    // effects && effects.forEach(fn => fn())
    const effectsToRun = new Set()
    // 如果trigger触发执行的副作用函数与当前正在执行的副作用函数想听，则不触发执行
    effects && effects.forEach(effectFn => {
      if (effectFn !== activeEffect) {
        effectsToRun.add(effectFn)
      }
    })
    // 当操作为ADD或DELETE时，触发ITERATE_KETY相关副作用函数重新执行
    if (type === 'ADD' || type === 'DELETE') {
      // 将与ITERATE_KEY相关的副作用函数也添加到effectsToRun
      iterateEffects && iterateEffects.forEach(effectFn => {
        if (effectFn !== activeEffect) {
          effectsToRun.add(effectFn)
        }
      })
    }

    // 当操作类型为ADD并目标对象是数组时，应该取出并执行那些与length属相相关的副作用函数
    if (type === 'ADD' && Array.isArray(target)) {
      // 取出与length相关的副作用函数
      const lengthEffects = depsMap.get('length')
      // 将与length相关的副作用函数添加到effectsToRun
      lengthEffects && lengthEffects.forEach(effectFn => {
        if (effectFn !== activeEffect) {
          effectsToRun.add(effectFn)
        }
      })
    }
    // 如果操作目标是数组，并且修改了数组的length属性
    if (Array.isArray(target) && key === 'length') {
      // 对于索引大于或等于新的length值的元素
      // 需要把所有相关联的副作用函数取出并添加到effectsToRun 中待执行
      depsMap.forEach((effects, key) => {
        if (key >= newVal) {
          effects.forEach(effectFn => {
            if (effectFn !== activeEffect) {
              effectsToRun.add(effectFn)
            }
          })
        }
      })
    }
    effectsToRun.forEach(effectFn => {
      // 如果副作用函数存在调度器，则调用该调度器，并将副作用函数作为参数传递
      if (effectFn.options.scheduler) {
        effectFn.options.scheduler(effectFn)
      } else {
        effectFn()
      }
    })
  }

  let activeEffect
  const effectStack = []

  function effect (fn, options = {}) {
    const effectFn = () => {
      // cleanup函数完成清除工作
      cleanup(effectFn)
      activeEffect = effectFn
      // 在调用副作用函数前将当前副作用函数压入栈中
      effectStack.push(effectFn)
      // 将fn的执行结果存储到res中
      const res = fn()
      // 在当前副作用函数执行完毕，将当前富作用函数出栈，并把activeEffect还原为之前的值
      effectStack.pop()
      activeEffect = effectStack[effectStack.length - 1]
      // 将res作为effectFn的返回值
      return res
    }
    effectFn.options = options
    effectFn.deps = []
    if (!options.lazy) {
      // 执行副作用函数
      effectFn()
    }
    return effectFn
  }

  function cleanup (effectFn) {
    for (let i = 0; i < effectFn.deps.length; i++) {
      const deps = effectFn.deps[i]
      // 将effectFn从依赖集合中移除
      deps.delete(effectFn)
    }
    // 重置effectFn.deps数组
    effectFn.deps.length = 0
  }

  const jobQueue = new Set()
  const p = Promise.resolve()
  let isFlushing = false
  function flushJob () {
    if (isFlushing) return
    isFlushing = true
    p.then(() => {
      jobQueue.forEach(job => job())
    }).finally(() => {
      isFlushing = false
    })
  }
  // demo-1
  // effect(() => {
  //   console.log('run')
  //   document.body.innerText = obj.ok ? obj.text : 'not'
  // })

  // demo-2
  // let temp1, temp2
  // effect(function effectFn1 () {
  //   console.log('effectFn1 执行')
  //   effect(function effectFn2 () {
  //     console.log('effectFn2 执行')
  //     temp2 = obj.bar
  //   })
  //   temp1 = obj.foo
  // })
  // console.log('***************')
  // obj.foo = false

  // demo-3
  // effect(() => {
  //   obj.foo++
  // })

  // demo-4
  // effect(() => {
  //   console.log(obj.foo)
  // }, {
  //   scheduler(fn) {
  //     jobQueue.add(fn)
  //     flushJob()
  //   }
  // })
  // obj.foo++
  // obj.foo++
  // console.log('end')

  // demo-5 lazy
  // const effectFn = effect(() => obj.foo + obj.bar, {
  //   lazy: true
  // })
  // const value = effectFn()
  // console.log(value, 'value')

  // computed
  function computed (getter) {
    let value
    let dirty = true
    const effectFn = effect(getter, {
      lazy: true,
      scheduler () {
        if (!dirty) {
          dirty = true
          // 当计算属性依赖的响应式数据变化，手动调用trigger函数触发相应
          trigger(obj, 'value')
        }
      }
    })
    const obj = {
      get value () {
        if (dirty) {
          value = effectFn()
          dirty = false
        }
        track(obj, 'value')
        return value
      }
    }
    return obj
  }

  // const sumRes = computed(() => {
  //   return obj.foo + obj.bar
  // })
  // effect(() => {
  //   console.log(sumRes.value, '11111')
  // })
  // obj.foo = 100

  // watch
  function watch (source, cb, options = {}) {
    let getter
    if (typeof source === 'function') {
      getter = source
    } else {
      getter = () => traverse(source)
    }
    let oldValue, newValue
    // cleanup存储用户注册过的回调
    let cleanup
    function onInvalidated (fn) {
      // 将过期回调存储到cleanup中
      cleanup = fn
    }
    // 提取scheduler调度函数为一个独立job函数
    const job = () => {
      newValue = effectFn()
      // 在调用回调函数cb之前，先调用过期回调
      if (cleanup) {
        cleanup()
      }
      // 将onInvalidated作为第三个参数一边用户使用
      cb(newValue, oldValue, onInvalidated)
      oldValue = newValue
    }
    const effectFn = effect(
      () => getter(),
      {
        lazy: true,
        scheduler: () => {
          if (options.flush === 'post') {
            const p = Promise.resolve()
            t.then(job)
          } else {
            job()
          }
        }
      }
    )
    if (options.immediate) {
      // 立即执行
      job()
    } else {
      oldValue = effectFn()
    }
    console.log(oldValue, 'old')
  }
  function traverse (value, seen = new Set()) {
    // 如果要读取的数据是原始值，或者已经被读取过了，就什么也不做
    if (typeof value !== 'object' || value === null || seen.has(value)) return
    // 将数据添加到seen中，代表遍历的读取过了，避免循环引用
    seen.add(value)
    // 暂时不考虑数组等其他结构
    // 假设value就是一个对象，使用for...in读取对戏那个每一个值，并递归调用traverse进行处理
    for (const k in value) {
      traverse(value[k], seen)
    }
    return value
  }
  // watch(obj, (newVal, oldVal) => {
  //   console.log('变化了', newVal, oldVal)
  // }, {
  //   immediate: true,
  //   flush: 'post'
  // })
  // obj.foo++

  // reactive
  
  ;['includes', 'indexOf', 'lastIndexOf'].forEach(method => {
    const originMethod = Array.prototype[method]
    arrayInstrumentations[method] = function (...args) {
      // this 是代理对象，先在代理对象中查找，将结果存储到 res 中
      let res = originMethod.apply(this, args)

      if (res === false || res === -1) {
        // res 为 false 说明没找到，通过 this.raw 拿到原始数组，再去其中查找并更新 res 值
        res = originMethod.apply(this.raw, args)
      }
      // 返回最终结果
      return res
    }
  })



  function createReactive (data, isShallow = false, isReadonly = false) {
    return new Proxy(data, {
      ...proxyConfig,
      get (target, key, receiver) {
        console.log('get:', target, key)
        // 代理对象可以通过raw属性访问原始数据
        if (key === 'raw') {
          return target
        }
        // if (key === 'size') {
        //   track(target, ITERATE_KEY)
        //   return Reflect.get(target, key, receiver)
        // }
        // 如果操作的目标对象是数组，并且 key 存在于arrayInstrumentations 上，
        // 那么返回定义在 arrayInstrumentations 上的值
        if (Array.isArray(target) && arrayInstrumentations.hasOwnProperty(key)) {
          return Reflect.get(arrayInstrumentations, key, receiver)
        }
        // 添加判断，如果key的类型是Symbol，则不进行跟踪
        if (!isReadonly && typeof key !== 'symbol') {
          track(target, key)
        }

        const res = Reflect.get(target, key, receiver)

        if (isShallow) {
          return res
        }

        if (typeof res === 'object' && res !== null) {
          // 调用reactive将结果包装成响应式数据并返回
          return isReadonly ? readonly(res) : reactive(res)
        }
        return res
      },
      set (target, key, newVal, receiver) {
        console.log('set:', target, key)
        if (isReadonly) {
          console.warn('onlyread')
          return
        }
        // old
        const oldVal = target[key]
        // 如果属性不存在，则说明是添加新属性，否则是设置已有属性
        const type = Array.isArray(target)
          // 如果代理的目标是数组，则检测被设置的索引值是否小于数组长度
          // 如果是，则是SET 否则是ADD
          ? Number(key) < target.length ? 'SET' : 'ADD'
          : Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'
        const res = Reflect.set(target, key, newVal, receiver)
        // target === receiver.raw 说明recevier就是target的代理对象 --- 解决访问到原型属性上，多次触发trigger
        if (target === receiver.raw) {
          // 当新值和旧值不相等并且都不是NaN时才触发trigger
          if (oldVal !== newVal && (oldVal === oldVal || newVal === newVal)) {
            trigger(target, key, type, newVal)
          }
        }
        return res
      },
      deleteProperty (target, key, receiver) {
        if (isReadonly) {
          console.warn('onlyread')
          return
        }
        // 检查被操作属性是否是对象自己的属性
        const hadKey = Object.prototype.hasOwnProperty.call(target, key)
        // 使用Relect.deleteProperty删除属性
        const res = Reflect.deleteProperty(target, key)
        if (res && hadKey) {
          trigger(target, key, 'DELETE')
        }
        return res
      }
    })
  }
  // 深响应
  const reactiveMap = new Map()
  function reactive (data) {
    return createReactive(data)
    // 优先通过原始对象data寻找之前创建的代理对象，如果找到了，直接返回已有的代理对象
    // const existingProxy = reactiveMap.get(data)
    // if (existingProxy) return existingProxy
    // // 否则创建一个新的代理对象
    // const proxy = createReactive(data)
    // // 存储到map中，从何避免重复创建
    // reactiveMap.set(data, proxy)
    // return proxy
  }
  // 浅响应
  function shallowReactive (data) {
    return createReactive(data, true)
  }
  // 只读
  function readonly (data) {
    return createReactive(data, false, true)
  }
  // 浅只读
  function shallowReadonly (data) {
    return createReactive(data, true, true)
  }

  function ref (val) {
    const wrapper = {
      value: val
    }
    Object.defineProperty(wrapper, "__v_isRef", {
      value: true
    })
    return reactive(wrapper)
  }
  function toRef (obj, key) {
    const wrapper = {
      get value () {
        return obj[key]
      },
      // 允许设置值
      set value (val) {
        obj[key] = val
      }
    }
    // 定义__v_isRef
    Object.defineProperty(wrapper, '__v_isRef', {
      value: true
    })
    return wrapper
  }

  function toRefs (obj) {
    const ret = {}
    for (const key in obj) {
      ret[key] = toRef(obj, key)
    }
    return ret
  }

  function proxyRefs (target) {
    return new Proxy(target, {
      get(target, key, receiver) {
        const value = Reflect.get(target, key, receiver)
        // 自动脱ref，如果读取的值是ref，则返回他点 value
        return value.__v_isRef ? value.value : value
      },
      set (target, key, newValue, receiver) {
        const value = target[key]

        if (value.__v_isRef) {
          value.value = newValue
          return true
        }

        return Reflect.set(target, key, newValue, receiver)
      }
    })
  }

  function renderer (domString, container) {
    container.innerHTML = domString
  }
  const count = ref(1)
  
  effect(() => {
    renderer(`<span>${count.value}</span>`, document.getElementById('app'))
  })
  count.value++

  // const _reactive = reactive({a:2, obj: { b: 1 }})
  // effect(() => {
  //   console.log(_reactive.a, '***')
  // })
  // _reactive.obj.b = 2

  // const arr = reactive(['foo'])
  // effect(() => {
  //   for (const key in arr) {
  //     console.log(key, 'key')
  //   }
  // })
  // arr[1] = 'bar'
  // arr.length = 0

  // const obj1 = {}
  // const arr = reactive([obj1])
  // console.log(arr.includes(obj1))
</script>
</html>